
// 四角形ポリゴン用シェーダ

// テクスチャの設定
sampler2D g_BaseMap = sampler_state{
	minFilter = LinearMipMapLinear;
	magFilter = Linear;
	WrapS = ClampToEdge;
	WrapT = ClampToEdge;
};

// ビュープロジェクション変換行列
float4x4 g_ModelViewProjectionMatrix;

// ポリゴンのカラー
float4 g_Color;

// テクスチャ座標
float4 g_TextureRect;


// 入力頂点構造体
struct VS_INPUT {
   float4 position : POSITION;   // 頂点座標
   float3 normal   : NORMAL;
   float2 texcoord : TEXCOORD0;	 // テクスチャ座標
};

// 出力頂点構造体
struct VS_OUTPUT  {
   float4 position  : POSITION;  // 頂点座標
   float2 texcoord	: TEXCOORD0; // テクスチャ座標
};

// 頂点シェーダー
VS_OUTPUT vs_main( 
	VS_INPUT input,
	uniform float4x4 g_ModelViewProjectionMatrix
) {
	VS_OUTPUT  output;

    // 入力頂点を出力
    output.position = mul( input.position, g_ModelViewProjectionMatrix );
    
	// テクスチャ座標を求める
	float2 texcoord;
	texcoord.x = clamp( input.texcoord.x, g_TextureRect.x, g_TextureRect.z );
	texcoord.y = clamp( input.texcoord.y, g_TextureRect.y, g_TextureRect.w );
	output.texcoord = texcoord;

    return output;
}

// ピクセルシェーダー
float4 ps_main( VS_OUTPUT input ) : COLOR0 {
    
	// テクスチャのカラーを取得
	float4 baseColor = tex2D( g_BaseMap, input.texcoord );

	float4 color = baseColor * g_Color;

	color.a = baseColor.a;

	// カラーを出力
	return color;
}

// テクニック( アルファブレンド )
technique Quad
{
   // パス0
   pass Pass0
   {
	  ZEnable			= true;
	  ZWriteEnable		= true;
	  BlendEnable		= true;
	  DepthTestEnable	= true;
      DepthMask			= true;
	  CullFaceEnable	= false;
      AlphaBlendEnable  = true;
	  AlphaTestEnable	= true;
	  BlendFunc			= int2( SrcAlpha, OneMinusSrcAlpha );
	  BlendEquation		= FuncAdd;

      VertexProgram		= compile arbvp1 vs_main( g_ModelViewProjectionMatrix );      
      FragmentProgram	= compile arbfp1 ps_main();
   }
}

// テクニック( 加算ブレンド )
technique QuadAdd
{
   // パス0
   pass Pass0
   {
	  ZEnable			= true;
	  ZWriteEnable		= true;
	  BlendEnable		= true;
	  DepthTestEnable	= true;
	  DepthMask			= true;
	  CullFaceEnable	= false;
	  AlphaBlendEnable  = true;
	  AlphaTestEnable	= true;
	  BlendFunc			= int2( SrcAlpha, One );
	  BlendEquation		= FuncAdd;

	  VertexProgram		= compile arbvp1 vs_main( g_ModelViewProjectionMatrix );      
	  FragmentProgram	= compile arbfp1 ps_main();
   }
}

// EOF